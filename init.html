<html>
<head>
<title>Initial WebGL Modeling</title>
<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script id="shader-fs" type="x-shader/x-fragment">
  varying lowp vec4 vColor;
  void main(void) {
    gl_FragColor = vColor;
  }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec4 aVertexColor;
  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;  
  varying lowp vec4 vColor;
  void main(void) {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(aVertexPosition, 1.0);
    vColor = aVertexColor;
  }
</script>
<script type="text/javascript">
var gl;
var program;
function initGL() {
  var canvas = document.getElementById("canvas1");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight-200; // To be changed later, currently to accomidate joysticks.
  try {
      gl = canvas.getContext("experimental-webgl");
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
  } catch (e) {
  }
  if (!gl) {
      alert("Could not initialise WebGL. Visit http://caniuse.com/webgl to check browser support.");
  }
}
function getShader(id) {
  var shaderScript = document.getElementById(id);
  if (!shaderScript) {
    return null;
  }
  var str = "";
  var k = shaderScript.firstChild;
  while (k) {
    if (k.nodeType == 3) {
        str += k.textContent;
    }
    k = k.nextSibling;
  }
  var shader;
  if (shaderScript.type == "x-shader/x-fragment") {
    shader = gl.createShader(gl.FRAGMENT_SHADER);
  } else if (shaderScript.type == "x-shader/x-vertex") {
    shader = gl.createShader(gl.VERTEX_SHADER);
  } else {
    return null;
  }
  gl.shaderSource(shader, str);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}
function initShaders() {
  var fragmentShader = getShader("shader-fs");
  var vertexShader = getShader("shader-vs");
  program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    alert("Could not initialise shaders");
  }
  gl.useProgram(program);
  program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
  gl.enableVertexAttribArray(program.vertexPositionAttribute);
  program.vertexColorAttribute = gl.getAttribLocation(program, "aVertexColor");
  gl.enableVertexAttribArray(program.vertexColorAttribute);
  program.pMatrixUniform = gl.getUniformLocation(program, "projectionMatrix");
  program.mvMatrixUniform = gl.getUniformLocation(program, "modelViewMatrix");
}
function setMatrixUniforms() {
  gl.uniformMatrix4fv(program.pMatrixUniform, false, projectionMatrix);
  gl.uniformMatrix4fv(program.mvMatrixUniform, false, modelViewMatrix);
}
var cubeVerticesBuffer;
var cubeVerticesColorBuffer;
var cubeVerticesIndexBuffer;
var cubeVerticesIndexBuffer;
var squareVertexPositionBuffer;
var modelViewMatrix;
var projectionMatrix;
function initBuffers() {
  modelViewMatrix = mat4.create();
  projectionMatrix = mat4.create();
  cubeVerticesBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
  var vertices = [
    // Front face
    -1.0, -1.0,  1.0,
     1.0, -1.0,  1.0,
     1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,
    // Back face
    -1.0, -1.0, -1.0,
    -1.0,  1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0, -1.0, -1.0,
    // Top face
    -1.0,  1.0, -1.0,
    -1.0,  1.0,  1.0,
     1.0,  1.0,  1.0,
     1.0,  1.0, -1.0,
    // Bottom face
    -1.0, -1.0, -1.0,
     1.0, -1.0, -1.0,
     1.0, -1.0,  1.0,
    -1.0, -1.0,  1.0,
    // Right face
     1.0, -1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0,  1.0,  1.0,
     1.0, -1.0,  1.0,
    // Left face
    -1.0, -1.0, -1.0,
    -1.0, -1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0,  1.0, -1.0
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  var colors = [
    [1.0,  1.0,  1.0,  1.0],  // Front face: white
    [1.0,  0.0,  0.0,  1.0],  // Back face: red
    [0.0,  1.0,  0.0,  1.0],  // Top face: green
    [0.0,  0.0,  1.0,  1.0],  // Bottom face: blue
    [1.0,  1.0,  0.0,  1.0],  // Right face: yellow
    [1.0,  0.0,  1.0,  1.0]   // Left face: purple
  ];
  var generatedColors = [];
  for (j=0; j<6; j++) {
    var c = colors[j];
    for (var i=0; i<4; i++) {
      generatedColors = generatedColors.concat(c);
    }
  }
  cubeVerticesColorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW);
  cubeVerticesIndexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
  var cubeVertexIndices = [
    0,  1,  2,      0,  2,  3,  // Front
    4,  5,  6,      4,  6,  7,  // Back
    8,  9,  10,     8,  10, 11,  // Top
    12, 13, 14,     12, 14, 15,  // Bottom
    16, 17, 18,     16, 18, 19,  // Right
    20, 21, 22,     20, 22, 23  // Left
  ]
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
}
function degToRad(degrees) {
  return degrees * Math.PI / 180;
}

var pitch = 0.0;
var pitchRate = 0.0;
var yaw = 0.0;
var yawRate = 0.0;
var mouseDown = false;
var viewDown = false;
var moveDown = false;
var lastMouseX = null;
var lastMouseY = null;
var moveX = null;
var moveY = null;
var viewX = null;
var viewY = null;
var rotationMatrix = mat4.create();
mat4.identity(rotationMatrix);
function handleKeyDown(event) {
  if (event.keyCode == 37) {
    // Left Arrow Key (Move left)
    x = x - 0.2;
  } else if (event.keyCode == 38) {
    // Up Arrow Key (Move up)
    y = y + 0.2;
  } else if (event.keyCode == 39) {
    // Right Arrow Key (Move right)
    x = x + 0.2;
  } else if (event.keyCode == 40) {
    // Down Arrow Key (Move down)
    y = y - 0.2;
  } else if (event.keyCode == 87) {
    // W (Zoom in)
    z = z + 0.2;
  } else if (event.keyCode == 83) { 
    // S (Zoom out)
    z = z - 0.2;
  }
}
function handleMouseDown(event) {
  mouseDown = true;
  lastMouseX = event.clientX;
  lastMouseY = event.clientY;
}
function viewHandlerDown(event) {
  viewDown = true;
  var rect = document.getElementById("moveCenter").getBoundingClientRect();
  viewX = event.clientX - (rect.right-rect.width/2);
  viewY = (rect.bottom-rect.height/2)- event.clientY;
}  
function moveHandlerDown(event) {
  moveDown = true;
  var rect = document.getElementById("moveCenter").getBoundingClientRect();
  moveX = event.clientX - (rect.right-rect.width/2);
  moveY = (rect.bottom-rect.height/2)- event.clientY;
}
var newRotationMatrix = mat4.create();
function handleMouseMove(event) {
  if (!mouseDown && !moveDown && !viewDown) {
      return;
  }
  if (moveDown) {
    if (moveX > -40 && moveX < 0 + 40 && moveY > -40 && moveY < 40) {
      x = x + (moveX/80);
      y = y + (moveY/80);
    }
  }
  if (mouseDown) {
    var newX = event.clientX;
    var newY = event.clientY;
    var deltaX = newX - lastMouseX
    var newRotationMatrix = mat4.create();
    mat4.identity(newRotationMatrix);
    mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
    var deltaY = newY - lastMouseY;
    mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
    mat4.multiply(newRotationMatrix, rotationMatrix, rotationMatrix);
    lastMouseX = newX;
    lastMouseY = newY;
  }
  if (viewDown) {
    if (viewX > 0) {
      yawRate = 0.1;
    } else {
      yawRate = -0.1;
    }
    if (viewY > 0) {
      pitchRate = 0.1;
    } else {
      pitchRate = -0.1;
    }
    console.log(yawRate + " " + pitchRate);
  }
}
function handleMouseUp(event) {
  mouseDown = false;
  moveDown = false;
  viewDown = false;
}
var x = 0.0;
var y = 0.0;
var z = -7.0;
function drawScene() {
  gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, projectionMatrix);
  mat4.identity(modelViewMatrix);
  mat4.rotate(modelViewMatrix, degToRad(pitch), [1, 0, 0]);
  mat4.rotate(modelViewMatrix, degToRad(yaw), [0, 1, 0]);
  mat4.translate(modelViewMatrix, [x, y, z]);
  mat4.multiply(modelViewMatrix, rotationMatrix);
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesBuffer);
  gl.vertexAttribPointer(program.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer);
  gl.vertexAttribPointer(program.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
  setMatrixUniforms();
  gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
}
var lastTime = 0.0;
function tick() {  
  requestAnimFrame(tick);
  drawScene();
  var timeNow = new Date().getTime();
  if (yawRate != 0) {
    var elapsed = timeNow - lastTime;
    yaw = yaw + elapsed * yawRate;
    yawRate = 0;
  }
  if (pitchRate != 0) {
    var elapsed = timeNow - lastTime;
    pitch = pitch + elapsed * pitchRate;
    pitchRate = 0;
  }
  lastTime = timeNow;
}
function webGLStart() {
  initGL();
  initShaders();
  initBuffers();
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clearDepth(1.0);
  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LEQUAL);
  document.getElementById("canvas1").onmousedown = handleMouseDown;
  document.getElementById("viewStick").onmousedown = viewHandlerDown;
  document.getElementById("moveStick").onmousedown = moveHandlerDown;
  document.onmouseup = handleMouseUp;
  document.onmousemove = handleMouseMove;
  document.onkeydown = handleKeyDown;
  tick();
}
</script>

</head>
<body onload="webGLStart();" bgcolor="#000000" style="width: 100%; height: 100%; padding: 0px; border: 0px; margin: 0px; overflow: hidden;">
  <center>
    <canvas id="canvas1" style="padding=0.0em" width="500" height="500"></canvas>
    </br>
    <svg id="viewStick" width="100"height="100" style="padding-left:50px;padding-right:50px;">
      <circle cx="50" cy="50" r="40"  stroke="black" stroke-width="3" fill="#610B0B"/>
      <circle cx="50" cy="50" r="35"  stroke="black" stroke-width="2" fill="#B40404"/>
    </svg>
    <svg id="moveStick" width="100" height="100" style="padding-left:50px;padding-right:50px;">
      <circle cx="50" cy="50" r="40" style="padding-left:50px;" stroke="black" stroke-width="3" fill="#610B0B"/>
      <circle id="moveCenter" cx="50" cy="50" r="35"  stroke="black" stroke-width="2" fill="#B40404"/>
    </svg>
  </center>
</body>
</html>
